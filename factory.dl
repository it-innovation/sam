/* vim: set syntax=prolog : */


/* Config */

isA("alice", "Unknown").
isA("bob", "Unknown").
isA("factory", "Factory").
value("alice", "ref", "factory").
value("bob", "ref", "factory").

hasVar("Unknown", "ref").


/* Behaviour */

maycall("Unknown", ?X, ?Y, ?Z) :- hasVar("Unknown", ?X), hasVar("Unknown", ?Y), hasVar("Unknown", ?Z).
hasParameter("Unknown", "ref").
mayreturn("Unknown", ?X) :- hasVar("Unknown", ?X).

maycreate("Factory", "Task", "task").
mayreturn("Factory", "task").

/* isA(?X, "Unknown") :- isA(?X, "Task"). */


/* System */

isObject(?X) :- isA(?X, ?Type).
isInvocation(?Invocation) :- hasInvocation(?Object, ?Invocation).

/* The concrete objects that may be called, based on the behaviour (in terms of variables) and the values of those variables. */
mayCallObject(?Caller, ?TargetValue, ?ArgValue, ?ReturnVar) :- isA(?Caller, ?Type), maycall(?Type, ?TargetVar, ?ArgVar, ?ReturnVar), value(?Caller, ?TargetVar, ?TargetValue), value(?Caller, ?ArgVar, ?ArgValue).

/* Caller did a call if caller might do "def _ := targetVar(argVar)" */
didcall(?Caller, ?TargetInvocation, ?ArgValue) :- mayCallObject(?Caller, ?TargetValue, ?ArgValue, ?ReturnVar), invocationObject(?Caller, ?TargetValue, ?TargetInvocation).

/* If Caller may call target and may accept a return value and target may return a value then Caller's var may now be the returned value. */
didget(?Caller, ?TargetInvocation, ?ReturnVar, ?ReturnValue) :- mayCallObject(?Caller, ?TargetObject, ?ArgValue, ?ReturnVar), invocationObject(?Caller, ?TargetObject, ?TargetInvocation), isA(?TargetObject, ?TargetType), mayreturn(?TargetType, ?TargetReturnVar), value(?TargetInvocation, ?TargetReturnVar, ?ReturnValue).

/* The caller may store the result of any call. */
value(?Caller, ?ReturnVar, ?ReturnValue) :- didget(?Caller, ?TargetInvocation, ?ReturnVar, ?ReturnValue).

/* Target's parameter variable may contain ArgValue if someone called it with that value. */
value(?TargetInvocation, ?ParamVar, ?ArgValue) :- hasInvocation(?Target, ?TargetInvocation), isA(?Target, ?Type), hasParameter(?Type, ?ParamVar), didcall(?Caller, ?TargetInvocation, ?ArgValue).

/* Every object has a 'this' variable with a reference to itself. */
hasVar(?X, "this") :- isA(?Object, ?X).
value(?X, "this", ?X) :- isA(?X, ?Type), hasVar(?Type, "this").

/* All parameters are variables */
hasVar(?X, ?Var) :- hasParameter(?X, ?Var).

value(?Invocation, ?Var, ?NewChild) :- hasInvocation(?Object, ?Invocation), isA(?Object, ?Type), maycreate(?Type, ?ChildType, ?Var), aggregatedChild(?Invocation, ?ChildType, ?NewChild).

/* If we specified a separate invocation object, use that. Otherwise, use the object itself. */
invocationObject(?Sender, ?Target, ?Invocation) :- aggregateInvocations(?Sender, ?Target, ?Invocation).
invocationObject(?Sender, ?Target, ?Target) :- isObject(?Sender), isObject(?Target), !aggregateInvocations(?Sender, ?Target, ?Invocation).
hasInvocation(?Object, ?Invocation) :- invocationObject(?Sender, ?Object, ?Invocation).
hasVar(?Invocation, ?Var) :- hasInvocation(?Object, ?Invocation), hasVar(?Object, ?Var).
value(?Invocation, ?Var, ?Value) :- hasInvocation(?Object, ?Invocation), value(?Object, ?Var, ?Value).
/* isA(?Invocation, ?Type) :- hasInvocation(?Object, ?Invocation), isA(?Object, ?Type). */


isA(?NewObject, ?Type) :- aggregatedChild(?Caller, ?Type, ?NewObject).

/* Aggregation */

aggregateInvocations("alice", "factory", "factory(alice)").
aggregateInvocations("bob", "factory", "factory(bob)").
/* aggregatedChild("factory", "Task", "newTasks"). */
aggregatedChild("factory(alice)", "Task", "newTasks(alice)").
aggregatedChild("factory(bob)", "Task", "newTasks(bob)").


/* An object is willing to create a new object, but we didn't say how to aggregate it. */
wantCreate(?Invocation, ?ChildType) :- isInvocation(?Invocation), isA(?Invocation, ?Type), maycreate(?Type, ?ChildType, ?Var).
error(?Invocation, ?ChildType) :- wantCreate(?Invocation, ?ChildType), !aggregatedChild(?Object, ?ChildType, ?NewChild).

error('Not an object (no type!)', ?Object) :- value(?X, ?Var, ?Object), !isObject(?Object).


/* Graphing */

access(?Caller, ?Object) :- value(?Caller, ?Var, ?Object), ?Caller != ?Object.
access(?Caller, ?Invocation) :- value(?Caller, ?Var, ?Object), invocationObject(?Caller, ?Object, ?Invocation), ?Caller != ?Invocation.

/* Goals */

error('newTasks(alice) accessible to Bob!', 1) :- access('bob', 'newTasks(alice)').


?- isA(?X, ?Y).
?- didcall(?Caller, ?Target, ?Arg).
?- value(?Object, ?Name, ?Value).
?- value('newTasks(alice)', ?V, ?Value).
?- hasParameter(?Target, ?P).
?- didget(?Caller, ?Invocation, ?Var, 'bob').
