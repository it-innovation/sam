/* vim: set syntax=prolog : */


/* Config */

isA("alice", "Unknown").
isA("bob", "Unknown").
isA("factory", "Factory").
value("alice", "ref", "factory").
value("bob", "ref", "factory").

hasVar("Unknown", "ref").


/* Behaviour */

maycall("Unknown", ?X, ?Y, ?Z) :- hasVar("Unknown", ?X), hasVar("Unknown", ?Y), hasVar("Unknown", ?Z).
hasParameter("Unknown", "ref").
mayreturn("Unknown", ?X) :- hasVar("Unknown", ?X).

maycreate("Factory", "Task", "task").
mayreturn("Factory", "task").

isField("Unknown", ?X) :- hasVar("Unknown", ?X).

isA(?X, "Unknown") :- isA(?X, "Task").


/* System */

isObject(?X) :- isA(?X, ?Type).
isInvocation(?Invocation) :- hasInvocation(?Object, ?Invocation).

/* The concrete objects that may be called, based on the behaviour (in terms of variables) and the values of those variables. */
mayCallObject(?Caller, ?TargetValue, ?ArgValue, ?ReturnVar) :- isA(?Caller, ?Type), maycall(?Type, ?TargetVar, ?ArgVar, ?ReturnVar), value(?Caller, ?TargetVar, ?TargetValue), value(?Caller, ?ArgVar, ?ArgValue).

/* Caller did a call if caller might do "def _ := targetVar(argVar)" */
didcall(?Caller, ?TargetInvocation, ?ArgValue) :- mayCallObject(?Caller, ?TargetValue, ?ArgValue, ?ReturnVar), invocationObject(?Caller, ?TargetValue, ?TargetInvocation).

/* If Caller may call target and may accept a return value and target may return a value then Caller's var may now be the returned value. */
didget(?Caller, ?TargetInvocation, ?ReturnVar, ?ReturnValue) :- mayCallObject(?Caller, ?TargetObject, ?ArgValue, ?ReturnVar), invocationObject(?Caller, ?TargetObject, ?TargetInvocation), isA(?TargetObject, ?TargetType), mayreturn(?TargetType, ?TargetReturnVar), value(?TargetInvocation, ?TargetReturnVar, ?ReturnValue).

/* The caller may store the result of any call. */
value(?Caller, ?ReturnVar, ?ReturnValue) :- didget(?Caller, ?TargetInvocation, ?ReturnVar, ?ReturnValue).

/* Target's parameter variable may contain ArgValue if someone called it with that value. */
value(?TargetInvocation, ?ParamVar, ?ArgValue) :- hasInvocation(?Target, ?TargetInvocation), isA(?Target, ?Type), hasParameter(?Type, ?ParamVar), didcall(?Caller, ?TargetInvocation, ?ArgValue).

/* Every object has a 'this' variable with a reference to itself. */
hasVar(?X, "this") :- isA(?Object, ?X).
value(?X, "this", ?X) :- isA(?X, ?Type), hasVar(?Type, "this").

/* All parameters are variables */
hasVar(?X, ?Var) :- hasParameter(?X, ?Var).

value(?Invocation, ?Var, ?NewChild) :- hasInvocation(?Object, ?Invocation), isA(?Object, ?Type), maycreate(?Type, ?ChildType, ?Var), newObject(?Invocation, ?ChildType, ?NewChild).

/* Fields are stores on the object, not just the invocation. */
/* value(?Object, ?Var, ?Value) :- hasInvocation(?Object, ?Invocation), isA(?Object, ?Type), isField(?Type, ?Var), value(?Invocation, ?Var, ?Value). */

/* If we specified a separate invocation object, use that. Otherwise, use the object itself. */
invocationObject(?Sender, ?Target, ?Invocation) :- aggregateInvocations(?Sender, ?Target, ?Invocation).
invocationObject(?Sender, ?Target, ?Target) :- isObject(?Sender), isObject(?Target), !aggregateInvocations(?Sender, ?Target, ?Invocation).
hasInvocation(?Object, ?Invocation) :- invocationObject(?Sender, ?Object, ?Invocation), didcall(?Someone, ?Invocation, ?SomeArg).
hasVar(?Invocation, ?Var) :- hasInvocation(?Object, ?Invocation), hasVar(?Object, ?Var).
/* value(?Invocation, ?Var, ?Value) :- hasInvocation(?Object, ?Invocation), value(?Object, ?Var, ?Value). */
/* isA(?Invocation, ?Type) :- hasInvocation(?Object, ?Invocation), isA(?Object, ?Type). */


isA(?NewObject, ?Type) :- newObject(?Invocation, ?Type, ?NewObject).

newObject(?Invocation, ?ChildType, ?NewObject) :- aggregatedChild(?Invocation, ?ChildType, ?NewObject).
newObject(?Invocation, ?ChildType, ?Object) :- maycreate(?ParentType, ?ChildType, ?Var), hasInvocation(?Object, ?Invocation), isA(?Object, ?ParentType), !aggregatedChild(?Invocation, ?ChildType, ?NewObject).


/* Aggregation */

aggregateInvocations("alice", "factory", "factory(alice)").
aggregateInvocations("newTasks(alice)", "factory", "factory(alice)").
aggregateInvocations("bob", "factory", "factory(bob)").
aggregateInvocations("newTasks(bob)", "factory", "factory(bob)").

/* aggregateInvocations("newTasks", "factory", "factory(bob)"). */
aggregatedChild("factory", "Task", "newTasks").

aggregatedChild("factory(alice)", "Task", "newTasks(alice)").
aggregatedChild("factory(bob)", "Task", "newTasks(bob)").


error('Not an object (no type!)', ?Object) :- value(?X, ?Var, ?Object), !isObject(?Object).


/* Graphing */

/*
graphObjects(?Caller, ?Object) :- value(?Caller, ?Var, ?Object), ?Caller != ?Object.
graphInvocable(?Caller, ?Invocation) :- value(?Caller, ?Var, ?Object), invocationObject(?Caller, ?Object, ?Invocation), ?Caller != ?Invocation.
*/

graphObjects(?Caller, ?Object) :- isObject(?Caller), value(?Caller, ?Var, ?Object), ?Caller != ?Object.


/* Goals */

error('newTasks(alice) accessible to Bob!', 1) :- value('bob', ?Var, 'newTasks(alice)').


?- isA(?X, ?Y).
?- invocationObject(?Caller, ?Object, ?Invocation).
