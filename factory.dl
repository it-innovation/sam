/* vim: set syntax=prolog : */

/*
Variables: v_factory, v_a, v_b, v_makeUnknown, v_makeUnknown.refs
Objects: factory, makeUnknown, newA, newOther
Types: makeUnknownT, factoryT, taskT
Invocations: factory_a, factory_other
*/


/* Config */

isA("alice", "Unknown").
isA("factory", "Factory").
value("alice", "ref", "factory").

hasVar("Unknown", "ref").

/*
may.invoke(top, v_makeUnknown, v_factory, v_a)
may.invoke(top, v_makeUnknown, v_factory, v_b).
maybe.invoked(_, v_makeUnknown, argValue) => maybe(v_makeUnknown.refs, argValue).
may.create(factory, taskT).
*/

/* Behaviour */

maycall("Unknown", ?X, ?Y, ?Z) :- hasVar("Unknown", ?X), hasVar("Unknown", ?Y), hasVar("Unknown", ?Z).
hasParameter("Unknown", "ref").
mayreturn("Unknown", ?X) :- hasVar("Unknown", ?X).

maycreate("Factory", "Task", "task").
mayreturn("Factory", "task").


/* System */

/* Caller did a call if caller might do "def _ := targetVar(argVar)" */
didcall(?Caller, ?TargetValue, ?ArgValue) :- isA(?Caller, ?Type), maycall(?Type, ?TargetVar, ?ArgVar, ?ReturnVar), value(?Caller, ?TargetVar, ?TargetValue), value(?Caller, ?ArgVar, ?ArgValue).

/* If Caller did call target and may accept a return value and target may return a value then Caller's var may now be the returned value. */
value(?Caller, ?ReturnVar, ?ReturnValue) :- didcall(?Caller, ?TargetValue, ?ArgValue), isA(?Caller, ?Type), maycall(?Type, ?TargetVar, ?ArgVar, ?ReturnVar), isA(?TargetValue, ?TargetType), mayreturn(?TargetType, ?TargetReturnVar), value(?TargetValue, ?TargetReturnVar, ?ReturnValue).

/* Target's parameter variable may contain ArgValue if someone called it with that value. */
value(?Target, ?ParamVar, ?ArgValue) :- isA(?Target, ?Type), hasParameter(?Type, ?ParamVar), didcall(?Caller, ?Target, ?ArgValue).

/* Every object has a 'this' variable with a reference to itself. */
hasVar(?X, "this") :- isA(?Object, ?X).
value(?X, "this", ?X) :- isA(?X, ?Type), hasVar(?Type, "this").

/* All parameters are variables */
hasVar(?X, ?Var) :- hasParameter(?X, ?Var).

value(?Object, ?Var, ?NewChild) :- isA(?Object, ?Type), maycreate(?Type, ?ChildType, ?Var), aggregatedChild(?Object, ?ChildType, ?NewChild).


/*
live(caller), may.invoke(caller, targetVar, argVar), maybe(targetVar, targetValue), maybe(argVar, argValue) => did.invoke(caller, targetValue, argValue)
did.invoke(_, target, _) => live(target).
did.invoke(caller, target, resultVar), aggregate(caller, new) => maybe(resultVar, new).

may.invoke(caller, target, arg), aggregate(caller, target, invocation) => did.invoke(caller, invocation, arg).
*/


/* Aggregation */

aggregatedChild("factory", "Task", "newTasks").


/*
Config:

maybe(factory, factory).
maybe(makeUnknown, makeUnknown).
live(top).


Run:

maybe.invoked(makeUnknown, factory).
live(makeUnknown).
may.invoke(makeUnknown, makeUnknown.refs, makeUnknown.refs).
maybe(makeUnknown.refs, factory).
maybe.invoked(factory, factory).
*/


/* An object is willing to create a new object, but we didn't say how to aggregate it. */
wantCreate(?Object, ?ChildType) :- isA(?Object, ?Type), maycreate(?Type, ?ChildType, ?Var).
error(?Object, ?ChildType) :- wantCreate(?Object, ?ChildType), !aggregatedChild(?Object, ?ChildType, ?NewChild).


?- isA(?X, ?Y).
?- didcall(?Caller, ?Target, ?Arg).
?- value(?Object, ?Name, ?Value).
?- error(?Object, ?ChildType).
