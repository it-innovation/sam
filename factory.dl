/* vim: set syntax=prolog : */


/* Config */

isA("alice", "Unknown").
isA("bob", "Unknown").
isA("factory", "Factory").
value("alice", "ref", "factory").
value("bob", "ref", "factory").

hasVar("Unknown", "ref").


/* Behaviour */

maycall("Unknown", ?X, ?Y, ?Z) :- hasVar("Unknown", ?X), hasVar("Unknown", ?Y), hasVar("Unknown", ?Z).
hasParameter("Unknown", "ref").
mayreturn("Unknown", ?X) :- hasVar("Unknown", ?X).

maycreate("Factory", "Task", "task").
mayreturn("Factory", "task").


/* System */

isObject(?X) :- isA(?X, ?Type).

/* The concrete objects that may be called, based on the behaviour (in terms of variables) and the values of those variables. */
mayCallObject(?Caller, ?TargetValue, ?ArgValue, ?ReturnVar) :- isA(?Caller, ?Type), maycall(?Type, ?TargetVar, ?ArgVar, ?ReturnVar), value(?Caller, ?TargetVar, ?TargetValue), value(?Caller, ?ArgVar, ?ArgValue).

/* Caller did a call if caller might do "def _ := targetVar(argVar)" */
didcall(?Caller, ?TargetInvocation, ?ArgValue) :- mayCallObject(?Caller, ?TargetValue, ?ArgValue, ?ReturnVar), invocationObject(?Caller, ?TargetValue, ?TargetInvocation).

/* If Caller did call target and may accept a return value and target may return a value then Caller's var may now be the returned value. */
value(?Caller, ?ReturnVar, ?ReturnValue) :- didcall(?Caller, ?TargetValue, ?ArgValue), isA(?Caller, ?Type), maycall(?Type, ?TargetVar, ?ArgVar, ?ReturnVar), isA(?TargetValue, ?TargetType), mayreturn(?TargetType, ?TargetReturnVar), value(?TargetValue, ?TargetReturnVar, ?ReturnValue).

/* Target's parameter variable may contain ArgValue if someone called it with that value. */
value(?Target, ?ParamVar, ?ArgValue) :- isA(?Target, ?Type), hasParameter(?Type, ?ParamVar), didcall(?Caller, ?Target, ?ArgValue).

/* Every object has a 'this' variable with a reference to itself. */
hasVar(?X, "this") :- isA(?Object, ?X).
value(?X, "this", ?X) :- isA(?X, ?Type), hasVar(?Type, "this").

/* All parameters are variables */
hasVar(?X, ?Var) :- hasParameter(?X, ?Var).

value(?Object, ?Var, ?NewChild) :- isA(?Object, ?Type), maycreate(?Type, ?ChildType, ?Var), aggregatedChild(?Object, ?ChildType, ?NewChild).

/* If we specified a separate invocation object, use that. Otherwise, use the object itself. */
invocationObject(?Sender, ?Target, ?Invocation) :- aggregateInvocations(?Sender, ?Target, ?Invocation).
invocationObject(?Sender, ?Target, ?Target) :- isObject(?Sender), isObject(?Target), !aggregateInvocations(?Sender, ?Target, ?Invocation).
hasInvocation(?Object, ?Invocation) :- invocationObject(?Sender, ?Object, ?Invocation).
hasVar(?Invocation, ?Var) :- hasInvocation(?Object, ?Invocation), hasVar(?Object, ?Var).
value(?Invocation, ?Var, ?Value) :- hasInvocation(?Object, ?Invocation), value(?Object, ?Var, ?Value).
isA(?Invocation, ?Type) :- hasInvocation(?Object, ?Invocation), isA(?Object, ?Type).


isA(?NewObject, ?Type) :- aggregatedChild(?Caller, ?Type, ?NewObject).

/* Aggregation */

aggregateInvocations("alice", "factory", "factory(alice)").
aggregatedChild("factory", "Task", "newTasks").
aggregatedChild("factory(alice)", "Task", "newTasks(alice)").


/* An object is willing to create a new object, but we didn't say how to aggregate it. */
wantCreate(?Object, ?ChildType) :- isA(?Object, ?Type), maycreate(?Type, ?ChildType, ?Var).
error(?Object, ?ChildType) :- wantCreate(?Object, ?ChildType), !aggregatedChild(?Object, ?ChildType, ?NewChild).

error('Not an object (no type!)', ?Object) :- access(?X, ?Object), !isA(?Object, ?Type).


/* Graphing */

/* access(?Caller, ?Object) :- value(?Caller, ?Var, ?Object), ?Caller != ?Object. */
access(?Caller, ?Invocation) :- value(?Caller, ?Var, ?Object), invocationObject(?Caller, ?Object, ?Invocation), ?Caller != ?Invocation.

/* Goals */

error('newTasks(alice) accessible to Bob!', 1) :- access('bob', 'newTasks(alice)').


?- isA(?X, ?Y).
?- didcall(?Caller, ?Target, ?Arg).
?- value(?Object, ?Name, ?Value).
?- access(?X, ?Y).
