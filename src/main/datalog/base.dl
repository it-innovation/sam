/* vim: set syntax=prolog : */

/////////////////////////////////////////////////////////////////////////
//
// Â© University of Southampton IT Innovation Centre, 2011
//
// Copyright in this library belongs to the University of Southampton
// University Road, Highfield, Southampton, UK, SO17 1BJ
//
// This software may not be used, sold, licensed, transferred, copied
// or reproduced in whole or in part in any manner or form or in or
// on any media by any person other than in accordance with the terms
// of the Licence Agreement supplied with the software, or otherwise
// without the prior written consent of the copyright owners.
//
// This software is distributed WITHOUT ANY WARRANTY, without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE, except where stated in the Licence Agreement supplied with
// the software.
//
//	Created By :			Thomas Leonard
//	Created Date :			2011-03-26
//	Created for Project :		SERSCIS
//
/////////////////////////////////////////////////////////////////////////
//
//  License : GNU Lesser General Public License, version 2.1
//
/////////////////////////////////////////////////////////////////////////

/* declarations */

declare definedType(?Type).
declare field(?Object, ?FieldName, ?Value).
declare getsAccess(?SourceObject, ?TargetObject).
declare haveBadAccess(?SourceObject, ?TargetObject).
declare isA(?Object, ?Type).
declare isInvocation(?Invocation).
declare isObject(?Object).
declare live(?Object).
declare liveMethod(?Object, ?Invocation, ?Method).
declare local(?Object, ?Invocation, ?VarName, ?Value).
declare realInvocationObject(?Caller, ?CallerInvocation, ?CallSite, ?TargetInvocation).
declare invocationObject(?Caller, ?CallerInvocation, ?CallSite, ?TargetInvocation).
declare value(?Object, ?Invocation, ?VarName, ?Value).
declare hasMethod(?Type, ?Method).
declare hasCallSite(?Method, ?CallSite).
declare initialObject(?Object, ?Type).
declare initialInvocation(?Object, ?Invocation).
declare realInitialInvocation(?Object, ?Invocation).
declare realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild).
declare denyAccess(?Object, ?Target).
declare requireAccess(?Object, ?Target).
declare hasField(?Type, ?FieldName).
declare isType(?Type).
declare missingGoodAccess(?SourceObject, ?TargetObject).

declare graphNode(?Node, ?Attrs).
declare graphEdge(?Source, ?Target, ?Attrs).
declare debugEdge(?Source, ?SourceInvocation, ?CallSite, ?Target, ?TargetInvocation).
declare showAllInvocations(?Object).
declare showInvocation(?Object, ?Invocation).

declare didCall(?Caller, ?CallerInvocation, ?CallSite, ?Target, ?TargetInvocation, ?Method).
declare mayAccept(?Method, ?ParamVar).
declare mayAccept(?Method, ?ParamVar, ?Value).

declare accessControlOn.
declare accessAllowed(?Caller, ?Target).
declare accessAllowed(?Caller, ?Target, ?Method).
declare methodMatches(?CallSite, ?Target, ?Method).
declare callsMethod(?CallSite, ?MethodName).
declare methodName(?Method, ?MethodName).
declare callsAnyMethod(?CallSite).
declare mayCallObject(?Caller, ?CallerInvocation, ?CallSite, ?Target).
declare didCreate(?Caller, ?Invocation, ?CallSite, ?NewChild).
declare hasConstructor(?Type, ?Method).
declare didGet(?Caller, ?CallerInvocation, ?CallSite, ?ResultValue).
declare didGetException(?Caller, ?CallerInvocation, ?CallSite, ?Exception).
declare mayReturn(?Object, ?Invocation, ?Method, ?Value).
declare mayThrow(?Object, ?Invocation, ?Method, ?Exception).
declare didAccept(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue).
declare maySend(?Target, ?TargetInvocation, ?Method, ?ArgValue).
declare maySend(?Target, ?TargetInvocation, ?Method, ?Pos, ?ArgValue).
declare mayCreate(?CallSite, ?ChildType).
declare newObject(?Object, ?Invocation, ?ChildType, ?NewObject).
declare debug.


/* aggregation */

/* realInvocationObject
 *
 * When Caller invokes Target in invocation context CallerInvocation, the context
 * of the resulting invocation at Target is the same, unless overridden by
 * invocationObject.
 */
realInvocationObject(?Caller, ?CallerInvocation, ?CallSite, ?TargetInvocation) :-
	invocationObject(?Caller, ?CallerInvocation, ?CallSite, ?TargetInvocation).
realInvocationObject(?Caller, ?CallerInvocation, ?CallSite, ?CallerInvocation) :-
	liveMethod(?Caller, ?CallerInvocation, ?Method),
	hasCallSite(?Method, ?CallSite),
	!invocationObject(?Caller, ?CallerInvocation, ?CallSite, ?AnyTargetInvocation).


/* predicates on objects */

isObject(?X) :- isA(?X, ?Type).
live(?Object) :- initialObject(?Object, ?Type).
isA(?Object, ?Type) :- initialObject(?Object, ?Type).
isA(?NewObject, ?Type) :- realNewObject(?Object, ?Invocation, ?Type, ?NewObject).
isType(?Type) :- definedType(?Type).
isA(?Object, "Unknown") :- isA(?Object, ?Type), !definedType(?Type).


/* predicates on invocations */

liveMethod(?Object, ?Invocation, ?Method) :-
	isA(?Object, ?Type),
	hasMethod(?Type, ?Method),
	realInitialInvocation(?Object, ?Invocation).

isInvocation(?Invocation) :- realInitialInvocation(?Object, ?Invocation).
isInvocation(?Invocation) :- invocationObject(?Caller, ?CallerInvocation, ?CallSite, ?Invocation).


/* assume Unknown objects are initially active in the "unknown" context, unless the user specified
 * a separate context.
 */
realInitialInvocation(?Object, ?Invocation) :- initialInvocation(?Object, ?Invocation).
realInitialInvocation(?Object, "unknown") :- initialObject(?Object, "Unknown"), !initialInvocation(?Object, ?AnyInvocation).

/* Every invocation has a "this" variable with a reference to its object. */
local(?Object, ?Invocation, "this", ?Object) :- liveMethod(?Object, ?Invocation, ?AnyMethod).

/* Local or field */
value(?Object, ?Invocation, ?Var, ?Value) :- local(?Object, ?Invocation, ?Var, ?Value).
value(?Object, ?Invocation, ?Var, ?Value) :- field(?Object, ?Var, ?Value), isInvocation(?Invocation).


/* Unknown behaviour */
class Unknown {
	private Object ref;

	public Unknown(Object args*) {
		this.*(args);
	}

	public Object *(Object args*) {
		try {
			ref = args;
			ref = this;
			ref = ref.*(ref);
			return ref;
			throw ref;
		} catch (Throwable ex) {
			ref = ex;
		}
	}
}

accessAllowed(?Source, ?Target, ?Method) :-
	accessAllowed(?Source, ?Target), hasMethod(?CallSite, ?Method).
