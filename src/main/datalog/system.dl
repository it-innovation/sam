/* vim: set syntax=prolog : */

/////////////////////////////////////////////////////////////////////////
//
// Â© University of Southampton IT Innovation Centre, 2011
//
// Copyright in this library belongs to the University of Southampton
// University Road, Highfield, Southampton, UK, SO17 1BJ
//
// This software may not be used, sold, licensed, transferred, copied
// or reproduced in whole or in part in any manner or form or in or
// on any media by any person other than in accordance with the terms
// of the Licence Agreement supplied with the software, or otherwise
// without the prior written consent of the copyright owners.
//
// This software is distributed WITHOUT ANY WARRANTY, without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE, except where stated in the Licence Agreement supplied with
// the software.
//
//	Created By :			Thomas Leonard
//	Created Date :			2011-03-26
//	Created for Project :		SERSCIS
//
/////////////////////////////////////////////////////////////////////////
//
//  License : GNU Lesser General Public License, version 2.1
//
/////////////////////////////////////////////////////////////////////////


/* Refinements */
mayAccept(?Method, ?ParamVar, ?Value) :- mayAccept(?Method, ?ParamVar), isObject(?Value).


/* Access control */

accessAllowed(?Caller, ?Target, ?Method) :-
	!accessControlOn,
	isObject(?Caller),
	isA(?Target, ?TargetType),
	hasMethod(?TargetType, ?Method).

/* Which methods may CallSite invoke on Target */
methodMatches(?CallSite, ?Target, ?Method) :-	/* Exact match */
	callsMethod(?CallSite, ?MethodName),
	isA(?Target, ?TargetType),
	hasMethod(?TargetType, ?Method),
	methodName(?Method, ?MethodName).
methodMatches(?CallSite, ?Target, ?Method) :-	/* Call may call any method */
	callsAnyMethod(?CallSite),
	isA(?Target, ?TargetType),
	hasMethod(?TargetType, ?Method).
methodMatches(?CallSite, ?Target, ?Method) :-	/* Any call matches a "*" method */
	methodName(?Method, "*"),
	hasCallSite(?CallerMethod, ?CallSite),
	isObject(?Target).

/* Assume caller did a call if caller might do "Object resultVar = targetObject.do(argValue)" */
/* note: can't rely on accessAllowed's hasMethod, becauser use may provide their own */
didCall(?Caller, ?CallerInvocation, ?CallSite, ?Target, ?TargetInvocation, ?Method) :-
	mayCallObject(?Caller, ?CallerInvocation, ?CallSite, ?Target),
	isA(?Target, ?TargetType),
	hasMethod(?TargetType, ?Method),
	methodMatches(?CallSite, ?Target, ?Method),
	accessAllowed(?Caller, ?Target, ?Method),
	realInvocationObject(?Caller, ?CallerInvocation, ?CallSite, ?TargetInvocation).

/* Parent calls the child"s constructor */
didCall(?Caller, ?Invocation, ?CallSite, ?NewChild, ?Invocation, ?Method) :-
	didCreate(?Caller, ?Invocation, ?CallSite, ?NewChild),
	isA(?NewChild, ?ChildType),
	hasConstructor(?ChildType, ?Method).

liveMethod(?Target, ?TargetInvocation, ?Method) :-
	didCall(?AnyCaller, ?AnyCallerInvocation, ?AnyCallSite, ?Target, ?TargetInvocation, ?Method).

/* Caller might call some target which may return Value. */
didGet(?Caller, ?CallerInvocation, ?CallSite, ?ResultValue) :-
	didCall(?Caller, ?CallerInvocation, ?CallSite, ?Target, ?TargetInvocation, ?Method),
	mayReturn(?Target, ?TargetInvocation, ?Method, ?ResultValue).

/* (might not have caught it, though) */
didGetException(?Caller, ?CallerInvocation, ?CallSite, ?Exception) :-
	didCall(?Caller, ?CallerInvocation, ?CallSite, ?Target, ?TargetInvocation, ?Method),
	mayThrow(?Target, ?TargetInvocation, ?Method, ?Exception).

/* (auto re-throw) */
mayThrow(?Caller, ?CallerInvocation, ?CallerMethod, ?Exception) :-
	hasCallSite(?CallerMethod, ?CallerCallSite),
	didCall(?Caller, ?CallerInvocation, ?CallerCallSite, ?Target, ?TargetInvocation, ?TargetMethod),
	didGetException(?Target, ?TargetInvocation, ?TargetCallSite, ?Exception).

didAccept(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue) :-
	maySend(?Target, ?TargetInvocation, ?Method, ?Pos, ?ArgValue),
	isA(?Target, ?TargetType),
	mayAccept(?Method, ?ParamVar, ?ArgValue).

/* (no position information; e.g. Unknown sender) */
didAccept(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue) :-
	maySend(?Target, ?TargetInvocation, ?Method, ?ArgValue),
	isA(?Target, ?TargetType),
	mayAccept(?Method, ?ParamVar, ?ArgValue).

/* Target"s parameter variable may contain ArgValue if someone called it with that value. */
local(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue) :-
	didAccept(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue).

didCreate(?Caller, ?Invocation, ?CallSite, ?Child) :-
	liveMethod(?Caller, ?Invocation, ?Method),
	hasCallSite(?Method, ?CallSite),
	mayCreate(?CallSite, ?ChildType),
	realNewObject(?Caller, ?Invocation, ?ChildType, ?Child).

live(?NewChild) :-
	didCreate(?Object, ?Invocation, ?CallSite, ?NewChild).


/* Default aggregation for child objects */

realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild) :- newObject(?Object, ?Invocation, ?ChildType, ?NewChild).
realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild) :-
	isA(?Object, ?Type),
	mayCreate(?CallSite, ?ChildType),
	isInvocation(?Invocation),
	!newObject(?Object, ?Invocation, ?ChildType, ?AnyChild),
	STRING_CONCAT(?Invocation, ?ChildType, ?NewChild).

/* Sanity checking */

error("Unknown source object in deny rule", ?A) :- denyAccess(?A, ?B), !isObject(?A).
error("Unknown target object in deny rule", ?B) :- denyAccess(?A, ?B), !isObject(?B).


/* Goal checking (here because we only check after applying the system rules) */

missingGoodAccess(?SourceObject, ?TargetObject) :-
	requireAccess(?SourceObject, ?TargetObject),
	!getsAccess(?SourceObject, ?TargetObject).

error("required access is not possible", ?SourceObject, ?TargetObject) :-
	missingGoodAccess(?SourceObject, ?TargetObject).

debug :- haveBadAccess(?Source, ?Target).
