/* vim: set syntax=prolog : */

/* Refinements */
mayAccept(?TargetType, ?ParamVar, ?Value) :- mayAccept(?TargetType, ?ParamVar), isObject(?Value).

//mayCall(?Type, ?TargetVar, ?Method, ?ArgVar, ?ResultVar) :- mayCall(?Type, ?TargetVar, ?ArgVar, ?ResultVar), isMethod(?Method).

/* Access control */

accessAllowed(?Caller, ?Target, ?CallSite) :-
	!accessControlOn,
	isA(?Caller, ?CallerType),
	isObject(?Target),
	hasCallSite(?CallerType, ?CallSite).

/* The concrete objects that may be called, based on the behaviour (in terms of variables) and the values of those variables. */
mayCallObject(?Caller, ?CallerInvocation, ?CallSite, ?Target) :-
	live(?Caller, ?CallerInvocation),
	isA(?Caller, ?Type),
	hasCallSite(?Type, ?CallSite),
	mayCall(?CallSite, ?TargetVar),
	accessAllowed(?Caller, ?Target, ?CallSite),
	value(?Caller, ?CallerInvocation, ?TargetVar, ?Target).

/* Assume caller did a call if caller might do "Object resultVar = targetObject.do(argValue)" */
didCall(?Caller, ?CallerInvocation, ?CallSite, ?Target, ?TargetInvocation) :-
	mayCallObject(?Caller, ?CallerInvocation, ?CallSite, ?Target),
	realInvocationObject(?Caller, ?CallerInvocation, ?CallSite, ?TargetInvocation).
error("No target invocation for possible call", ?Caller, ?CallerInvocation, ?CallSite, ?Target) :-
	mayCallObject(?Caller, ?CallerInvocation, ?CallSite, ?Target),
	!realInvocationObject(?Caller, ?CallerInvocation, ?CallSite, ?TargetInvocation).

live(?Target, ?TargetInvocation) :-
	didCall(?AnyCaller, ?AnyCallerInvocation, ?AnyCallSite, ?Target, ?TargetInvocation).

/* If Caller may call target and may accept a return value and target may return a value then Caller's var may now be the returned value. */
didGet(?Caller, ?CallerInvocation, ?CallSite, ?ResultValue) :-
	didCall(?Caller, ?CallerInvocation, ?CallSite, ?Target, ?TargetInvocation),
	isA(?Target, ?TargetType),
	mayReturn(?TargetType, ?TargetResultVar),
	value(?Target, ?TargetInvocation, ?TargetResultVar, ?ResultValue).

/* The caller may store the result of any call. */
local(?Caller, ?CallerInvocation, ?ResultVar, ?ResultValue) :-
	didGet(?Caller, ?CallerInvocation, ?CallSite, ?ResultValue),
	mayStore(?CallSite, ?ResultVar),
	isA(?Caller, ?Type),
	hasLocal(?Type, ?ResultVar).
field(?Caller, ?ResultVar, ?ResultValue) :-
	didGet(?Caller, ?CallerInvocation, ?CallSite, ?ResultValue),
	mayStore(?CallSite, ?ResultVar),
	isA(?Caller, ?Type),
	hasField(?Type, ?ResultVar).

didAccept(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue) :-
	didCall(?Caller, ?Invocation, ?CallSite, ?Target, ?TargetInvocation),
	mayPass(?CallSite, ?VarName),
	value(?Caller, ?Invocation, ?VarName, ?ArgValue),
	isA(?Target, ?TargetType),
	mayAccept(?TargetType, ?ParamVar, ?ArgValue).

/* Target's parameter variable may contain ArgValue if someone called it with that value. */
local(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue) :-
	didAccept(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue),
	hasLocal(?TargetType, ?ParamVar).
field(?Target, ?ParamVar, ?ArgValue) :-
	didAccept(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue),
	hasField(?TargetType, ?ParamVar).

didCreate(?Object, ?Invocation, ?Var, ?ChildType) :-
	live(?Object, ?Invocation),
	isA(?Object, ?Type),
	mayCreate(?Type, ?ChildType, ?Var).

local(?Object, ?Invocation, ?Var, ?NewChild) :-
	didCreate(?Object, ?Invocation, ?Var, ?ChildType),
	realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild).

live(?NewChild) :-
	didCreate(?Object, ?Invocation, ?Var, ?ChildType),
	realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild).


/* Default aggregation for child objects */

realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild) :- newObject(?Object, ?Invocation, ?ChildType, ?NewChild).
realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild) :-
	isA(?Object, ?Type),
	mayCreate(?Type, ?ChildType, ?Var),
	isInvocation(?Invocation),
	!newObject(?Object, ?Invocation, ?ChildType, ?AnyChild),
	STRING_CONCAT(?ChildType, ?Invocation, ?NewChild).

/* Sanity checking */

error('Unknown source object in deny rule', ?A) :- denyAccess(?A, ?B), !isObject(?A).
error('Unknown target object in deny rule', ?B) :- denyAccess(?A, ?B), !isObject(?B).


/* Goal checking (here because we only check after applying the system rules) */

missingGoodAccess(?SourceObject, ?TargetObject) :-
	requireAccess(?SourceObject, ?TargetObject),
	!getsAccess(?SourceObject, ?TargetObject).

error('required access is not possible', ?SourceObject, ?TargetObject) :-
	missingGoodAccess(?SourceObject, ?TargetObject).

debug :- haveBadAccess(?Source, ?Target).
