/* vim: set syntax=prolog : */

mayAccept(?TargetType, ?ParamVar, ?Value) :- mayAccept(?TargetType, ?ParamVar), isObject(?Value).

/* The concrete objects that may be called, based on the behaviour (in terms of variables) and the values of those variables. */
mayCallObject(?Caller, ?CallerInvocation, ?TargetValue, ?ArgValue, ?ResultVar) :-
	live(?Caller, ?CallerInvocation),
	isA(?Caller, ?Type),
	mayCall(?Type, ?TargetVar, ?ArgVar, ?ResultVar),
	value(?Caller, ?CallerInvocation, ?TargetVar, ?TargetValue),
	value(?Caller, ?CallerInvocation, ?ArgVar, ?ArgValue).

/* Assume caller did a call if caller might do "Object resultVar = targetObject.do(argValue)" */
didCall(?Caller, ?CallerInvocation, ?Target, ?TargetInvocation, ?ArgValue, ?ResultVar) :-
	mayCallObject(?Caller, ?CallerInvocation, ?Target, ?ArgValue, ?ResultVar),
	realInvocationObject(?Caller, ?CallerInvocation, ?Target, ?ArgValue, ?ResultVar, ?TargetInvocation).
error("No target invocation for possible call", ?Caller, ?CallerInvocation, ?Target) :-
	mayCallObject(?Caller, ?CallerInvocation, ?Target, ?ArgValue, ?ResultVar),
	!realInvocationObject(?Caller, ?CallerInvocation, ?Target, ?ArgValue, ?ResultVar, ?TargetInvocation).

live(?Target, ?TargetInvocation) :- didCall(?AnyCaller, ?AnyCallerInvocation, ?Target, ?TargetInvocation, ?A, ?R).

/* If Caller may call target and may accept a return value and target may return a value then Caller's var may now be the returned value. */
didGet(?Caller, ?CallerInvocation, ?ResultVar, ?ResultValue) :-
	didCall(?Caller, ?CallerInvocation, ?Target, ?TargetInvocation, ?ArgValue, ?ResultVar),
	isA(?Target, ?TargetType),
	mayReturn(?TargetType, ?TargetResultVar),
	value(?Target, ?TargetInvocation, ?TargetResultVar, ?ResultValue).

/* The caller may store the result of any call. */
local(?Caller, ?CallerInvocation, ?ResultVar, ?ResultValue) :-
	didGet(?Caller, ?CallerInvocation, ?ResultVar, ?ResultValue),
	isA(?Caller, ?Type),
	hasLocal(?Type, ?ResultVar).
field(?Caller, ?ResultVar, ?ResultValue) :-
	didGet(?Caller, ?AnyInvocation, ?ResultVar, ?ResultValue),
	isA(?Caller, ?Type),
	hasField(?Type, ?ResultVar).

/* Target's parameter variable may contain ArgValue if someone called it with that value. */
local(?Target, ?TargetInvocation, ?ParamVar, ?ArgValue) :-
	didCall(?AnyCaller, ?AnyInvocation, ?Target, ?TargetInvocation, ?ArgValue, ?ResultVar),
	isA(?Target, ?TargetType),
	hasLocal(?TargetType, ?ParamVar),
	mayAccept(?TargetType, ?ParamVar, ?ArgValue).
field(?Target, ?ParamVar, ?ArgValue) :-
	didCall(?AnyCaller, ?AnyInvocation, ?Target, ?TargetInvocation, ?ArgValue, ?ResultVar),
	isA(?Target, ?TargetType),
	hasField(?TargetType, ?ParamVar),
	mayAccept(?TargetType, ?ParamVar, ?ArgValue).

didCreate(?Object, ?Invocation, ?Var, ?ChildType) :-
	live(?Object, ?Invocation),
	isA(?Object, ?Type),
	mayCreate(?Type, ?ChildType, ?Var).

local(?Object, ?Invocation, ?Var, ?NewChild) :-
	didCreate(?Object, ?Invocation, ?Var, ?ChildType),
	realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild).

live(?NewChild) :-
	didCreate(?Object, ?Invocation, ?Var, ?ChildType),
	realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild).


/* Default aggregation for child objects */

realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild) :- newObject(?Object, ?Invocation, ?ChildType, ?NewChild).
realNewObject(?Object, ?Invocation, ?ChildType, ?NewChild) :-
	isA(?Object, ?Type),
	mayCreate(?Type, ?ChildType, ?Var),
	isInvocation(?Invocation),
	!newObject(?Object, ?Invocation, ?ChildType, ?AnyChild),
	STRING_CONCAT(?ChildType, ?Invocation, ?NewChild).

/* Sanity checking */

error('Unknown source object in deny rule', ?A) :- denyAccess(?A, ?B), !isObject(?A).
error('Unknown target object in deny rule', ?B) :- denyAccess(?A, ?B), !isObject(?B).


/* Goal checking (here because we only check after applying the system rules) */

missingGoodAccess(?SourceObject, ?TargetObject) :-
	requireAccess(?SourceObject, ?TargetObject),
	!getsAccess(?SourceObject, ?TargetObject).

error('required access is not possible', ?SourceObject, ?TargetObject) :-
	missingGoodAccess(?SourceObject, ?TargetObject).

debug :- haveBadAccess(?Source, ?Target).
