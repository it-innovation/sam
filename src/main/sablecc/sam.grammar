Package eu.serscis.sam;

Helpers
  unicode_input_character = [0..0xffff];
  ht  = 0x0009;
  lf  = 0x000a;
  ff  = 0x000c;
  cr  = 0x000d;
  sp  = ' ';
  char = ['a'..'z'] | ['A'..'Z'];
  digit = ['0'..'9'];
  line_terminator = lf | cr | cr lf;
  input_character = [unicode_input_character - [cr + lf]];
  not_star = [unicode_input_character - '*'];
  not_star_not_slash = [unicode_input_character - ['*' + '/']];
  underscode = '_';
  
  // (based on sablecc example Java grammar)
  escape_sequence = '\b' | '\t' | '\n' | '\f' | '\r' | '\"' | '\' ''' | '\\';
  string_character = [input_character - ['"' + '\']] | escape_sequence;

Tokens
  number = '-'? ['0' .. '9']+;
  l_par = '(';
  r_par = ')';
  public_tok = 'public';
  private_tok = 'private';
  extends_tok = 'extends';
  new = 'new';
  throw = 'throw';
  return = 'return';
  class_tok = 'class';
  at_tok = '@';
  l_brace = '{';
  r_brace = '}';
  eq = '=';
  blank = (' ' | 13 | 9 | 10)+;
  comment = '//' input_character* line_terminator;
  block_comment = '/*' not_star* ('*' not_star_not_slash*)* '*/';

  comma = ',';
  goal = 'goal';
  semi = ';';
  if_dl = ':-';
  bang = '!';
  string_literal = '"' string_character* '"';
  query_start = '?-';
  question = '?';
  binop = '=' | '!=';
  star = '*';
  dots = '...';
  dot = '.';
  declare_tok = 'declare';
  import_tok = 'import';
  config_tok = 'config';

  try = 'try';
  catch = 'catch';

  // must be last
  name = char(char|digit|underscode)*;

Ignored Tokens
  blank, comment, block_comment;

Productions
  program = toplevel+;
  toplevel = {behaviour} behaviour
  	   | {config} config
	   | {import} import
  	   | {fact} fact
  	   | {rule} rule
	   | {declare} declare
	   | {query} query;

  import = import_tok string_literal dot;

  declare = declare_tok atom dot;
  fact = atom dot;
  rule = [head]:atom if_dl [body]:literals dot;
  literals = literal literal_tail*;
  literal_tail = comma literal;
  literal = {positive} atom
  	  | {negative} bang atom;
  atom = {nullary} name
       | {normal} name l_par terms r_par
       | {builtin} [lhs]:term binop [rhs]:term;
  terms = term term_tail*;
  term_tail = comma term;
  term = {var} question name
       | {string} string_literal
       | {int} number
       | {composite} name l_par terms r_par;

  query = query_start literals dot;

  pattern = {named} name
          | {any} star;
  config = config_tok l_brace config_body r_brace;
  behaviour = class_tok name extends? l_brace class_body r_brace;
  extends = extends_tok name;
  class_body = field* method*;
  config_body = config_field* namedblock+;
  field = private_tok type name semi;
  config_field = type name semi;
  type = name;
  annotation = {noargs} at_tok name
             | {args} at_tok name l_par string_args? r_par;
  method = annotation* public_tok type? [name]:pattern l_par params? star? r_par l_brace code r_brace;
  code = statement*;
  assign = type? name eq;
  statement = {assign} assign? expr semi
            | {decl} type name semi
	    | {try} try l_brace statement* r_brace catch_block*
            | {throw} throw name semi
	    | {return} return name semi;
  catch_block = catch l_par type name r_par l_brace statement* r_brace;
  expr = {new} new type l_par args? star? r_par
       | {call} name dot [method]:pattern l_par args? star? r_par
       | {string} string_literal
       | {copy} name;
  string_args = string_literal string_args_tail*;
  string_args_tail = comma string_literal;
  args = expr args_tail*;
  args_tail = comma expr;
  param = type name;
  params = param params_tail*;
  params_tail = comma param;
  namedblock = name [context]:string_literal? l_brace code r_brace;
